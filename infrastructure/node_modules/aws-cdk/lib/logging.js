"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.highlight = exports.success = exports.trace = exports.debug = exports.data = exports.print = exports.info = exports.warning = exports.error = exports.LogLevel = void 0;
exports.setLogLevel = setLogLevel;
exports.setCI = setCI;
exports.withCorkedLogging = withCorkedLogging;
exports.log = log;
exports.prefix = prefix;
const util = require("util");
const chalk = require("chalk");
/**
 * Available log levels in order of increasing verbosity.
 */
var LogLevel;
(function (LogLevel) {
    LogLevel["ERROR"] = "error";
    LogLevel["WARN"] = "warn";
    LogLevel["INFO"] = "info";
    LogLevel["DEBUG"] = "debug";
    LogLevel["TRACE"] = "trace";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
const { stdout, stderr } = process;
// Corking mechanism
let CORK_COUNTER = 0;
const logBuffer = [];
// Style mappings
const styleMap = {
    [LogLevel.ERROR]: chalk.red,
    [LogLevel.WARN]: chalk.yellow,
    [LogLevel.INFO]: chalk.white,
    [LogLevel.DEBUG]: chalk.gray,
    [LogLevel.TRACE]: chalk.gray,
};
// Stream selection
let CI = false;
/**
 * Determines which output stream to use based on log level and configuration.
 * @param level - The log level to determine stream for
 * @param forceStdout - Whether to force stdout regardless of level
 * @returns The appropriate Writable stream
 */
const getStream = (level, forceStdout) => {
    // Special case - data() calls should always go to stdout
    if (forceStdout) {
        return stdout;
    }
    if (level === LogLevel.ERROR)
        return stderr;
    return CI ? stdout : stderr;
};
const levelPriority = {
    [LogLevel.ERROR]: 0,
    [LogLevel.WARN]: 1,
    [LogLevel.INFO]: 2,
    [LogLevel.DEBUG]: 3,
    [LogLevel.TRACE]: 4,
};
let currentLogLevel = LogLevel.INFO;
/**
 * Sets the current log level. Messages with a lower priority level will be filtered out.
 * @param level - The new log level to set
 */
function setLogLevel(level) {
    currentLogLevel = level;
}
/**
 * Sets whether the logger is running in CI mode.
 * In CI mode, all non-error output goes to stdout instead of stderr.
 * @param newCI - Whether CI mode should be enabled
 */
function setCI(newCI) {
    CI = newCI;
}
/**
 * Formats a date object into a timestamp string (HH:MM:SS).
 * @param d - Date object to format
 * @returns Formatted time string
 */
function formatTime(d) {
    const pad = (n) => n.toString().padStart(2, '0');
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
/**
 * Executes a block of code with corked logging. All log messages during execution
 * are buffered and only written after the block completes.
 * @param block - Async function to execute with corked logging
 * @returns Promise that resolves with the block's return value
 */
async function withCorkedLogging(block) {
    CORK_COUNTER++;
    try {
        return await block();
    }
    finally {
        CORK_COUNTER--;
        if (CORK_COUNTER === 0) {
            logBuffer.forEach(([stream, str]) => stream.write(str + '\n'));
            logBuffer.splice(0);
        }
    }
}
function log(levelOrEntry, fmt, ...args) {
    // Normalize input
    const entry = typeof levelOrEntry === 'string'
        ? { level: levelOrEntry, message: util.format(fmt, ...args) }
        : levelOrEntry;
    // Check if we should log this level
    if (levelPriority[entry.level] > levelPriority[currentLogLevel]) {
        return;
    }
    // Format the message
    let finalMessage = entry.message;
    // Add timestamp first if requested
    if (entry.timestamp) {
        finalMessage = `[${formatTime(new Date())}] ${finalMessage}`;
    }
    // Add prefix AFTER timestamp
    if (entry.prefix) {
        finalMessage = `${entry.prefix} ${finalMessage}`;
    }
    // Apply custom style if provided, otherwise use level-based style
    const style = entry.style || styleMap[entry.level];
    finalMessage = style(finalMessage);
    // Get appropriate stream - pass through forceStdout flag
    const stream = getStream(entry.level, entry.forceStdout);
    // Handle corking
    if (CORK_COUNTER > 0) {
        logBuffer.push([stream, finalMessage]);
        return;
    }
    // Write to stream
    stream.write(finalMessage + '\n');
}
// Convenience logging methods
const error = (fmt, ...args) => log(LogLevel.ERROR, fmt, ...args);
exports.error = error;
const warning = (fmt, ...args) => log(LogLevel.WARN, fmt, ...args);
exports.warning = warning;
const info = (fmt, ...args) => log(LogLevel.INFO, fmt, ...args);
exports.info = info;
const print = (fmt, ...args) => log(LogLevel.INFO, fmt, ...args);
exports.print = print;
const data = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    forceStdout: true,
});
exports.data = data;
const debug = (fmt, ...args) => log(LogLevel.DEBUG, fmt, ...args);
exports.debug = debug;
const trace = (fmt, ...args) => log(LogLevel.TRACE, fmt, ...args);
exports.trace = trace;
const success = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    style: chalk.green,
});
exports.success = success;
const highlight = (fmt, ...args) => log({
    level: LogLevel.INFO,
    message: util.format(fmt, ...args),
    style: chalk.bold,
});
exports.highlight = highlight;
/**
 * Creates a logging function that prepends a prefix to all messages.
 * @param prefixString - String to prepend to all messages
 * @param level - Log level to use (defaults to INFO)
 * @returns Logging function that accepts format string and arguments
 */
function prefix(prefixString, level = LogLevel.INFO) {
    return (fmt, ...args) => log({
        level,
        message: util.format(fmt, ...args),
        prefix: prefixString,
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2luZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxvZ2dpbmcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBMEVBLGtDQUVDO0FBT0Qsc0JBRUM7QUFrQkQsOENBV0M7QUFVRCxrQkF1Q0M7QUFpQ0Qsd0JBTUM7QUF6TUQsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUUvQjs7R0FFRztBQUNILElBQVksUUFNWDtBQU5ELFdBQVksUUFBUTtJQUNsQiwyQkFBZSxDQUFBO0lBQ2YseUJBQWEsQ0FBQTtJQUNiLHlCQUFhLENBQUE7SUFDYiwyQkFBZSxDQUFBO0lBQ2YsMkJBQWUsQ0FBQTtBQUNqQixDQUFDLEVBTlcsUUFBUSx3QkFBUixRQUFRLFFBTW5CO0FBY0QsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFFbkMsb0JBQW9CO0FBQ3BCLElBQUksWUFBWSxHQUFHLENBQUMsQ0FBQztBQUNyQixNQUFNLFNBQVMsR0FBeUIsRUFBRSxDQUFDO0FBRTNDLGlCQUFpQjtBQUNqQixNQUFNLFFBQVEsR0FBOEM7SUFDMUQsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdBQUc7SUFDM0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU07SUFDN0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUs7SUFDNUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUk7SUFDNUIsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLElBQUk7Q0FDN0IsQ0FBQztBQUVGLG1CQUFtQjtBQUNuQixJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUM7QUFFZjs7Ozs7R0FLRztBQUNILE1BQU0sU0FBUyxHQUFHLENBQUMsS0FBZSxFQUFFLFdBQXFCLEVBQVksRUFBRTtJQUNyRSx5REFBeUQ7SUFDekQs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QUksQ0FBQztJQUNsQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUs7Q0FDbkIsQ0FBQyxDQUFDO0FBSlUsUUFBQSxPQUFPLFdBSWpCO0FBRUksTUFBTSxTQUFTLEdBQUcsQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUNoRSxLQUFLLEVBQUUsUUFBUSxDQUFDLElBQUk7SUFDcEIsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLEtBQUssRUFBRSxLQUFLLENBQUMsSUFBSTtDQUNsQixDQUFDLENBQUM7QUFKVSxRQUFBLFNBQVMsYUFJbkI7QUFFSDs7Ozs7R0FLRztBQUNILFNBQWdCLE1BQU0sQ0FBQyxZQUFvQixFQUFFLFFBQWtCLFFBQVEsQ0FBQyxJQUFJO0lBQzFFLE9BQU8sQ0FBQyxHQUFXLEVBQUUsR0FBRyxJQUFlLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQztRQUM5QyxLQUFLO1FBQ0wsT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQ2xDLE1BQU0sRUFBRSxZQUFZO0tBQ3JCLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuXG4vKipcbiAqIEF2YWlsYWJsZSBsb2cgbGV2ZWxzIGluIG9yZGVyIG9mIGluY3JlYXNpbmcgdmVyYm9zaXR5LlxuICovXG5leHBvcnQgZW51bSBMb2dMZXZlbCB7XG4gIEVSUk9SID0gJ2Vycm9yJyxcbiAgV0FSTiA9ICd3YXJuJyxcbiAgSU5GTyA9ICdpbmZvJyxcbiAgREVCVUcgPSAnZGVidWcnLFxuICBUUkFDRSA9ICd0cmFjZScsXG59XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhIGxvZyBlbnRyeS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMb2dFbnRyeSB7XG4gIGxldmVsOiBMb2dMZXZlbDtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICB0aW1lc3RhbXA/OiBib29sZWFuO1xuICBwcmVmaXg/OiBzdHJpbmc7XG4gIHN0eWxlPzogKChzdHI6IHN0cmluZykgPT4gc3RyaW5nKTtcbiAgZm9yY2VTdGRvdXQ/OiBib29sZWFuO1xufVxuXG5jb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBwcm9jZXNzO1xuXG4vLyBDb3JraW5nIG1lY2hhbmlzbVxubGV0IENPUktfQ09VTlRFUiA9IDA7XG5jb25zdCBsb2dCdWZmZXI6IFtXcml0YWJsZSwgc3RyaW5nXVtdID0gW107XG5cbi8vIFN0eWxlIG1hcHBpbmdzXG5jb25zdCBzdHlsZU1hcDogUmVjb3JkPExvZ0xldmVsLCAoc3RyOiBzdHJpbmcpID0+IHN0cmluZz4gPSB7XG4gIFtMb2dMZXZlbC5FUlJPUl06IGNoYWxrLnJlZCxcbiAgW0xvZ0xldmVsLldBUk5dOiBjaGFsay55ZWxsb3csXG4gIFtMb2dMZXZlbC5JTkZPXTogY2hhbGsud2hpdGUsXG4gIFtMb2dMZXZlbC5ERUJVR106IGNoYWxrLmdyYXksXG4gIFtMb2dMZXZlbC5UUkFDRV06IGNoYWxrLmdyYXksXG59O1xuXG4vLyBTdHJlYW0gc2VsZWN0aW9uXG5sZXQgQ0kgPSBmYWxzZTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoaWNoIG91dHB1dCBzdHJlYW0gdG8gdXNlIGJhc2VkIG9uIGxvZyBsZXZlbCBhbmQgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSBsZXZlbCAtIFRoZSBsb2cgbGV2ZWwgdG8gZGV0ZXJtaW5lIHN0cmVhbSBmb3JcbiAqIEBwYXJhbSBmb3JjZVN0ZG91dCAtIFdoZXRoZXIgdG8gZm9yY2Ugc3Rkb3V0IHJlZ2FyZGxlc3Mgb2YgbGV2ZWxcbiAqIEByZXR1cm5zIFRoZSBhcHByb3ByaWF0ZSBXcml0YWJsZSBzdHJlYW1cbiAqL1xuY29uc3QgZ2V0U3RyZWFtID0gKGxldmVsOiBMb2dMZXZlbCwgZm9yY2VTdGRvdXQ/OiBib29sZWFuKTogV3JpdGFibGUgPT4ge1xuICAvLyBTcGVjaWFsIGNhc2UgLSBkYXRhKCkgY2FsbHMgc2hvdWxkIGFsd2F5cyBnbyB0byBzdGRvdXRcbiAgaWYgKGZvcmNlU3Rkb3V0KSB7XG4gICAgcmV0dXJuIHN0ZG91dDtcbiAgfVxuICBpZiAobGV2ZWwgPT09IExvZ0xldmVsLkVSUk9SKSByZXR1cm4gc3RkZXJyO1xuICByZXR1cm4gQ0kgPyBzdGRvdXQgOiBzdGRlcnI7XG59O1xuXG5jb25zdCBsZXZlbFByaW9yaXR5OiBSZWNvcmQ8TG9nTGV2ZWwsIG51bWJlcj4gPSB7XG4gIFtMb2dMZXZlbC5FUlJPUl06IDAsXG4gIFtMb2dMZXZlbC5XQVJOXTogMSxcbiAgW0xvZ0xldmVsLklORk9dOiAyLFxuICBbTG9nTGV2ZWwuREVCVUddOiAzLFxuICBbTG9nTGV2ZWwuVFJBQ0VdOiA0LFxufTtcblxubGV0IGN1cnJlbnRMb2dMZXZlbDogTG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgbG9nIGxldmVsLiBNZXNzYWdlcyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBmaWx0ZXJlZCBvdXQuXG4gKiBAcGFyYW0gbGV2ZWwgLSBUaGUgbmV3IGxvZyBsZXZlbCB0byBzZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldExvZ0xldmVsKGxldmVsOiBMb2dMZXZlbCkge1xuICBjdXJyZW50TG9nTGV2ZWwgPSBsZXZlbDtcbn1cblxuLyoqXG4gKiBTZXRzIHdoZXRoZXIgdGhlIGxvZ2dlciBpcyBydW5uaW5nIGluIENJIG1vZGUuXG4gKiBJbiBDSSBtb2RlLCBhbGwgbm9uLWVycm9yIG91dHB1dCBnb2VzIHRvIHN0ZG91dCBpbnN0ZWFkIG9mIHN0ZGVyci5cbiAqIEBwYXJhbSBuZXdDSSAtIFdoZXRoZXIgQ0kgbW9kZSBzaG91bGQgYmUgZW5hYmxlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q0kobmV3Q0k6IGJvb2xlYW4pIHtcbiAgQ0kgPSBuZXdDSTtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZSBvYmplY3QgaW50byBhIHRpbWVzdGFtcCBzdHJpbmcgKEhIOk1NOlNTKS5cbiAqIEBwYXJhbSBkIC0gRGF0ZSBvYmplY3QgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgdGltZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VGltZShkOiBEYXRlKTogc3RyaW5nIHtcbiAgY29uc3QgcGFkID0gKG46IG51bWJlcik6IHN0cmluZyA9PiBuLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgcmV0dXJuIGAke3BhZChkLmdldEhvdXJzKCkpfToke3BhZChkLmdldE1pbnV0ZXMoKSl9OiR7cGFkKGQuZ2V0U2Vjb25kcygpKX1gO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgYmxvY2sgb2YgY29kZSB3aXRoIGNvcmtlZCBsb2dnaW5nLiBBbGwgbG9nIG1lc3NhZ2VzIGR1cmluZyBleGVjdXRpb25cbiAqIGFyZSBidWZmZXJlZCBhbmQgb25seSB3cml0dGVuIGFmdGVyIHRoZSBibG9jayBjb21wbGV0ZXMuXG4gKiBAcGFyYW0gYmxvY2sgLSBBc3luYyBmdW5jdGlvbiB0byBleGVjdXRlIHdpdGggY29ya2VkIGxvZ2dpbmdcbiAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBibG9jaydzIHJldHVybiB2YWx1ZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2l0aENvcmtlZExvZ2dpbmc8VD4oYmxvY2s6ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgQ09SS19DT1VOVEVSKys7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGJsb2NrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgQ09SS19DT1VOVEVSLS07XG4gICAgaWYgKENPUktfQ09VTlRFUiA9PT0gMCkge1xuICAgICAgbG9nQnVmZmVyLmZvckVhY2goKFtzdHJlYW0sIHN0cl0pID0+IHN0cmVhbS53cml0ZShzdHIgKyAnXFxuJykpO1xuICAgICAgbG9nQnVmZmVyLnNwbGljZSgwKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3JlIGxvZ2dpbmcgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGFsbCBsb2cgb3V0cHV0LlxuICogQHBhcmFtIGVudHJ5IC0gTG9nRW50cnkgb2JqZWN0IG9yIGxvZyBsZXZlbFxuICogQHBhcmFtIGZtdCAtIEZvcm1hdCBzdHJpbmcgKHdoZW4gdXNpbmcgd2l0aCBsb2cgbGV2ZWwpXG4gKiBAcGFyYW0gYXJncyAtIEZvcm1hdCBhcmd1bWVudHMgKHdoZW4gdXNpbmcgd2l0aCBsb2cgbGV2ZWwpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2coZW50cnk6IExvZ0VudHJ5KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsb2cobGV2ZWw6IExvZ0xldmVsLCBmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsb2cobGV2ZWxPckVudHJ5OiBMb2dMZXZlbCB8IExvZ0VudHJ5LCBmbXQ/OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSk6IHZvaWQge1xuICAvLyBOb3JtYWxpemUgaW5wdXRcbiAgY29uc3QgZW50cnk6IExvZ0VudHJ5ID0gdHlwZW9mIGxldmVsT3JFbnRyeSA9PT0gJ3N0cmluZydcbiAgICA/IHsgbGV2ZWw6IGxldmVsT3JFbnRyeSBhcyBMb2dMZXZlbCwgbWVzc2FnZTogdXRpbC5mb3JtYXQoZm10ISwgLi4uYXJncykgfVxuICAgIDogbGV2ZWxPckVudHJ5O1xuXG4gIC8vIENoZWNrIGlmIHdlIHNob3VsZCBsb2cgdGhpcyBsZXZlbFxuICBpZiAobGV2ZWxQcmlvcml0eVtlbnRyeS5sZXZlbF0gPiBsZXZlbFByaW9yaXR5W2N1cnJlbnRMb2dMZXZlbF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JtYXQgdGhlIG1lc3NhZ2VcbiAgbGV0IGZpbmFsTWVzc2FnZSA9IGVudHJ5Lm1lc3NhZ2U7XG5cbiAgLy8gQWRkIHRpbWVzdGFtcCBmaXJzdCBpZiByZXF1ZXN0ZWRcbiAgaWYgKGVudHJ5LnRpbWVzdGFtcCkge1xuICAgIGZpbmFsTWVzc2FnZSA9IGBbJHtmb3JtYXRUaW1lKG5ldyBEYXRlKCkpfV0gJHtmaW5hbE1lc3NhZ2V9YDtcbiAgfVxuXG4gIC8vIEFkZCBwcmVmaXggQUZURVIgdGltZXN0YW1wXG4gIGlmIChlbnRyeS5wcmVmaXgpIHtcbiAgICBmaW5hbE1lc3NhZ2UgPSBgJHtlbnRyeS5wcmVmaXh9ICR7ZmluYWxNZXNzYWdlfWA7XG4gIH1cblxuICAvLyBBcHBseSBjdXN0b20gc3R5bGUgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSB1c2UgbGV2ZWwtYmFzZWQgc3R5bGVcbiAgY29uc3Qgc3R5bGUgPSBlbnRyeS5zdHlsZSB8fCBzdHlsZU1hcFtlbnRyeS5sZXZlbF07XG4gIGZpbmFsTWVzc2FnZSA9IHN0eWxlKGZpbmFsTWVzc2FnZSk7XG5cbiAgLy8gR2V0IGFwcHJvcHJpYXRlIHN0cmVhbSAtIHBhc3MgdGhyb3VnaCBmb3JjZVN0ZG91dCBmbGFnXG4gIGNvbnN0IHN0cmVhbSA9IGdldFN0cmVhbShlbnRyeS5sZXZlbCwgZW50cnkuZm9yY2VTdGRvdXQpO1xuXG4gIC8vIEhhbmRsZSBjb3JraW5nXG4gIGlmIChDT1JLX0NPVU5URVIgPiAwKSB7XG4gICAgbG9nQnVmZmVyLnB1c2goW3N0cmVhbSwgZmluYWxNZXNzYWdlXSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV3JpdGUgdG8gc3RyZWFtXG4gIHN0cmVhbS53cml0ZShmaW5hbE1lc3NhZ2UgKyAnXFxuJyk7XG59XG5cbi8vIENvbnZlbmllbmNlIGxvZ2dpbmcgbWV0aG9kc1xuZXhwb3J0IGNvbnN0IGVycm9yID0gKGZtdDogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pID0+IGxvZyhMb2dMZXZlbC5FUlJPUiwgZm10LCAuLi5hcmdzKTtcbmV4cG9ydCBjb25zdCB3YXJuaW5nID0gKGZtdDogc3RyaW5nLCAuLi5hcmdzOiB1bmtub3duW10pID0+IGxvZyhMb2dMZXZlbC5XQVJOLCBmbXQsIC4uLmFyZ3MpO1xuZXhwb3J0IGNvbnN0IGluZm8gPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKExvZ0xldmVsLklORk8sIGZtdCwgLi4uYXJncyk7XG5leHBvcnQgY29uc3QgcHJpbnQgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKExvZ0xldmVsLklORk8sIGZtdCwgLi4uYXJncyk7XG5leHBvcnQgY29uc3QgZGF0YSA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coe1xuICBsZXZlbDogTG9nTGV2ZWwuSU5GTyxcbiAgbWVzc2FnZTogdXRpbC5mb3JtYXQoZm10LCAuLi5hcmdzKSxcbiAgZm9yY2VTdGRvdXQ6IHRydWUsXG59KTtcbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coTG9nTGV2ZWwuREVCVUcsIGZtdCwgLi4uYXJncyk7XG5leHBvcnQgY29uc3QgdHJhY2UgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKExvZ0xldmVsLlRSQUNFLCBmbXQsIC4uLmFyZ3MpO1xuXG5leHBvcnQgY29uc3Qgc3VjY2VzcyA9IChmbXQ6IHN0cmluZywgLi4uYXJnczogdW5rbm93bltdKSA9PiBsb2coe1xuICBsZXZlbDogTG9nTGV2ZWwuSU5GTyxcbiAgbWVzc2FnZTogdXRpbC5mb3JtYXQoZm10LCAuLi5hcmdzKSxcbiAgc3R5bGU6IGNoYWxrLmdyZWVuLFxufSk7XG5cbmV4cG9ydCBjb25zdCBoaWdobGlnaHQgPSAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKHtcbiAgbGV2ZWw6IExvZ0xldmVsLklORk8sXG4gIG1lc3NhZ2U6IHV0aWwuZm9ybWF0KGZtdCwgLi4uYXJncyksXG4gIHN0eWxlOiBjaGFsay5ib2xkLFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dpbmcgZnVuY3Rpb24gdGhhdCBwcmVwZW5kcyBhIHByZWZpeCB0byBhbGwgbWVzc2FnZXMuXG4gKiBAcGFyYW0gcHJlZml4U3RyaW5nIC0gU3RyaW5nIHRvIHByZXBlbmQgdG8gYWxsIG1lc3NhZ2VzXG4gKiBAcGFyYW0gbGV2ZWwgLSBMb2cgbGV2ZWwgdG8gdXNlIChkZWZhdWx0cyB0byBJTkZPKVxuICogQHJldHVybnMgTG9nZ2luZyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgZm9ybWF0IHN0cmluZyBhbmQgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXgocHJlZml4U3RyaW5nOiBzdHJpbmcsIGxldmVsOiBMb2dMZXZlbCA9IExvZ0xldmVsLklORk8pOiAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gdm9pZCB7XG4gIHJldHVybiAoZm10OiBzdHJpbmcsIC4uLmFyZ3M6IHVua25vd25bXSkgPT4gbG9nKHtcbiAgICBsZXZlbCxcbiAgICBtZXNzYWdlOiB1dGlsLmZvcm1hdChmbXQsIC4uLmFyZ3MpLFxuICAgIHByZWZpeDogcHJlZml4U3RyaW5nLFxuICB9KTtcbn1cbiJdfQ==