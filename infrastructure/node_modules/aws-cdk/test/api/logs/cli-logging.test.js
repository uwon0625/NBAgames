"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("../../../lib/logging");
describe('logging', () => {
    // Mock streams to capture output
    let mockStdout;
    let mockStderr;
    // Helper function to strip ANSI codes
    const stripAnsi = (str) => {
        const ansiRegex = /\u001b\[[0-9;]*[a-zA-Z]/g;
        return str.replace(ansiRegex, '');
    };
    beforeEach(() => {
        // Reset log level before each test
        (0, logging_1.setLogLevel)(logging_1.LogLevel.INFO);
        (0, logging_1.setCI)(false);
        // Create mock functions to capture output
        mockStdout = jest.fn();
        mockStderr = jest.fn();
        // Mock the write methods directly and strip ANSI codes
        jest.spyOn(process.stdout, 'write').mockImplementation((chunk) => {
            mockStdout(stripAnsi(chunk.toString()));
            return true;
        });
        jest.spyOn(process.stderr, 'write').mockImplementation((chunk) => {
            mockStderr(stripAnsi(chunk.toString()));
            return true;
        });
    });
    afterEach(() => {
        jest.restoreAllMocks();
    });
    describe('stream selection', () => {
        test('data() always writes to stdout', () => {
            (0, logging_1.data)('test message');
            expect(mockStdout).toHaveBeenCalledWith('test message\n');
            expect(mockStderr).not.toHaveBeenCalled();
        });
        test('error() always writes to stderr', () => {
            (0, logging_1.error)('test error');
            expect(mockStderr).toHaveBeenCalledWith('test error\n');
            expect(mockStdout).not.toHaveBeenCalled();
        });
        test('print() writes to stderr by default', () => {
            (0, logging_1.print)('test print');
            expect(mockStderr).toHaveBeenCalledWith('test print\n');
            expect(mockStdout).not.toHaveBeenCalled();
        });
        test('print() writes to stdout in CI mode', () => {
            (0, logging_1.setCI)(true);
            (0, logging_1.print)('test print');
            expect(mockStdout).toHaveBeenCalledWith('test print\n');
            expect(mockStderr).not.toHaveBeenCalled();
        });
    });
    describe('log levels', () => {
        test('respects log level settings', () => {
            (0, logging_1.setLogLevel)(logging_1.LogLevel.ERROR);
            (0, logging_1.error)('error message');
            (0, logging_1.warning)('warning message');
            (0, logging_1.print)('print message');
            expect(mockStderr).toHaveBeenCalledWith('error message\n');
            expect(mockStderr).not.toHaveBeenCalledWith('warning message\n');
            expect(mockStderr).not.toHaveBeenCalledWith('print message\n');
        });
        test('debug messages only show at debug level', () => {
            (0, logging_1.setLogLevel)(logging_1.LogLevel.INFO);
            (0, logging_1.debug)('debug message');
            expect(mockStderr).not.toHaveBeenCalled();
            (0, logging_1.setLogLevel)(logging_1.LogLevel.DEBUG);
            (0, logging_1.debug)('debug message');
            expect(mockStderr).toHaveBeenCalledWith('debug message\n');
        });
        test('trace messages only show at trace level', () => {
            (0, logging_1.setLogLevel)(logging_1.LogLevel.DEBUG);
            (0, logging_1.trace)('trace message');
            expect(mockStderr).not.toHaveBeenCalled();
            (0, logging_1.setLogLevel)(logging_1.LogLevel.TRACE);
            (0, logging_1.trace)('trace message');
            expect(mockStderr).toHaveBeenCalledWith('trace message\n');
        });
    });
    describe('message formatting', () => {
        test('formats messages with multiple arguments', () => {
            (0, logging_1.print)('Value: %d, String: %s', 42, 'test');
            expect(mockStderr).toHaveBeenCalledWith('Value: 42, String: test\n');
        });
        test('handles prefix correctly', () => {
            const prefixedLog = (0, logging_1.prefix)('PREFIX');
            prefixedLog('test message');
            expect(mockStderr).toHaveBeenCalledWith('PREFIX test message\n');
        });
        test('handles custom styles', () => {
            (0, logging_1.success)('success message');
            expect(mockStderr).toHaveBeenCalledWith('success message\n');
        });
    });
    describe('corked logging', () => {
        test('buffers messages when corked', async () => {
            await (0, logging_1.withCorkedLogging)(async () => {
                (0, logging_1.print)('message 1');
                (0, logging_1.print)('message 2');
                expect(mockStderr).not.toHaveBeenCalled();
            });
            expect(mockStderr).toHaveBeenCalledWith('message 1\n');
            expect(mockStderr).toHaveBeenCalledWith('message 2\n');
        });
        test('handles nested corking correctly', async () => {
            await (0, logging_1.withCorkedLogging)(async () => {
                (0, logging_1.print)('outer 1');
                await (0, logging_1.withCorkedLogging)(async () => {
                    (0, logging_1.print)('inner');
                });
                (0, logging_1.print)('outer 2');
                expect(mockStderr).not.toHaveBeenCalled();
            });
            expect(mockStderr).toHaveBeenCalledTimes(3);
            expect(mockStderr).toHaveBeenCalledWith('outer 1\n');
            expect(mockStderr).toHaveBeenCalledWith('inner\n');
            expect(mockStderr).toHaveBeenCalledWith('outer 2\n');
        });
    });
    describe('timestamp and prefix handling', () => {
        test('combines timestamp and prefix correctly', () => {
            (0, logging_1.log)({
                level: logging_1.LogLevel.INFO,
                message: 'test message',
                timestamp: true,
                prefix: 'PREFIX',
            });
            expect(mockStderr).toHaveBeenCalledWith(expect.stringMatching(/^PREFIX \[\d{2}:\d{2}:\d{2}\] test message\n$/));
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWxvZ2dpbmcudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsaS1sb2dnaW5nLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxrREFBd0o7QUFFeEosUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUU7SUFDdkIsaUNBQWlDO0lBQ2pDLElBQUksVUFBcUIsQ0FBQztJQUMxQixJQUFJLFVBQXFCLENBQUM7SUFFMUIsc0NBQXNDO0lBQ3RDLE1BQU0sU0FBUyxHQUFHLENBQUMsR0FBVyxFQUFVLEVBQUU7UUFDeEMsTUFBTSxTQUFTLEdBQUcsMEJBQTBCLENBQUM7UUFDN0MsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNwQyxDQUFDLENBQUM7SUFFRixVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2QsbUNBQW1DO1FBQ25DLElBQUEscUJBQVcsRUFBQyxrQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNCLElBQUEsZUFBSyxFQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWIsMENBQTBDO1FBQzFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDdkIsVUFBVSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztRQUV2Qix1REFBdUQ7UUFDdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsS0FBVSxFQUFFLEVBQUU7WUFDcEUsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxLQUFVLEVBQUUsRUFBRTtZQUNw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QUFnQixFQUFFLENBQUM7WUFDNUMsQ0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3JELE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNuRCxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsb0JBQW9CLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDdkQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztJQUVILFFBQVEsQ0FBQywrQkFBK0IsRUFBRSxHQUFHLEVBQUU7UUFDN0MsSUFBSSxDQUFDLHlDQUF5QyxFQUFFLEdBQUcsRUFBRTtZQUNuRCxJQUFBLGFBQUcsRUFBQztnQkFDRixLQUFLLEVBQUUsa0JBQVEsQ0FBQyxJQUFJO2dCQUNwQixPQUFPLEVBQUUsY0FBYztnQkFDdkIsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsTUFBTSxFQUFFLFFBQVE7YUFDakIsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLG9CQUFvQixDQUNyQyxNQUFNLENBQUMsY0FBYyxDQUFDLCtDQUErQyxDQUFDLENBQ3ZFLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMb2dMZXZlbCwgbG9nLCBzZXRMb2dMZXZlbCwgc2V0Q0ksIGRhdGEsIHByaW50LCBlcnJvciwgd2FybmluZywgc3VjY2VzcywgZGVidWcsIHRyYWNlLCBwcmVmaXgsIHdpdGhDb3JrZWRMb2dnaW5nIH0gZnJvbSAnLi4vLi4vLi4vbGliL2xvZ2dpbmcnO1xuXG5kZXNjcmliZSgnbG9nZ2luZycsICgpID0+IHtcbiAgLy8gTW9jayBzdHJlYW1zIHRvIGNhcHR1cmUgb3V0cHV0XG4gIGxldCBtb2NrU3Rkb3V0OiBqZXN0Lk1vY2s7XG4gIGxldCBtb2NrU3RkZXJyOiBqZXN0Lk1vY2s7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHN0cmlwIEFOU0kgY29kZXNcbiAgY29uc3Qgc3RyaXBBbnNpID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBhbnNpUmVnZXggPSAvXFx1MDAxYlxcW1swLTk7XSpbYS16QS1aXS9nO1xuICAgIHJldHVybiBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKTtcbiAgfTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBSZXNldCBsb2cgbGV2ZWwgYmVmb3JlIGVhY2ggdGVzdFxuICAgIHNldExvZ0xldmVsKExvZ0xldmVsLklORk8pO1xuICAgIHNldENJKGZhbHNlKTtcblxuICAgIC8vIENyZWF0ZSBtb2NrIGZ1bmN0aW9ucyB0byBjYXB0dXJlIG91dHB1dFxuICAgIG1vY2tTdGRvdXQgPSBqZXN0LmZuKCk7XG4gICAgbW9ja1N0ZGVyciA9IGplc3QuZm4oKTtcblxuICAgIC8vIE1vY2sgdGhlIHdyaXRlIG1ldGhvZHMgZGlyZWN0bHkgYW5kIHN0cmlwIEFOU0kgY29kZXNcbiAgICBqZXN0LnNweU9uKHByb2Nlc3Muc3Rkb3V0LCAnd3JpdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oKGNodW5rOiBhbnkpID0+IHtcbiAgICAgIG1vY2tTdGRvdXQoc3RyaXBBbnNpKGNodW5rLnRvU3RyaW5nKCkpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgamVzdC5zcHlPbihwcm9jZXNzLnN0ZGVyciwgJ3dyaXRlJykubW9ja0ltcGxlbWVudGF0aW9uKChjaHVuazogYW55KSA9PiB7XG4gICAgICBtb2NrU3RkZXJyKHN0cmlwQW5zaShjaHVuay50b1N0cmluZygpKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LnJlc3RvcmVBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnc3RyZWFtIHNlbGVjdGlvbicsICgpID0+IHtcbiAgICB0ZXN0KCdkYXRhKCkgYWx3YXlzIHdyaXRlcyB0byBzdGRvdXQnLCAoKSA9PiB7XG4gICAgICBkYXRhKCd0ZXN0IG1lc3NhZ2UnKTtcbiAgICAgIGV4cGVjdChtb2NrU3Rkb3V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdCBtZXNzYWdlXFxuJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2Vycm9yKCkgYWx3YXlzIHdyaXRlcyB0byBzdGRlcnInLCAoKSA9PiB7XG4gICAgICBlcnJvcigndGVzdCBlcnJvcicpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCd0ZXN0IGVycm9yXFxuJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZG91dCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3ByaW50KCkgd3JpdGVzIHRvIHN0ZGVyciBieSBkZWZhdWx0JywgKCkgPT4ge1xuICAgICAgcHJpbnQoJ3Rlc3QgcHJpbnQnKTtcbiAgICAgIGV4cGVjdChtb2NrU3RkZXJyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdCBwcmludFxcbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRvdXQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdwcmludCgpIHdyaXRlcyB0byBzdGRvdXQgaW4gQ0kgbW9kZScsICgpID0+IHtcbiAgICAgIHNldENJKHRydWUpO1xuICAgICAgcHJpbnQoJ3Rlc3QgcHJpbnQnKTtcbiAgICAgIGV4cGVjdChtb2NrU3Rkb3V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndGVzdCBwcmludFxcbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsb2cgbGV2ZWxzJywgKCkgPT4ge1xuICAgIHRlc3QoJ3Jlc3BlY3RzIGxvZyBsZXZlbCBzZXR0aW5ncycsICgpID0+IHtcbiAgICAgIHNldExvZ0xldmVsKExvZ0xldmVsLkVSUk9SKTtcbiAgICAgIGVycm9yKCdlcnJvciBtZXNzYWdlJyk7XG4gICAgICB3YXJuaW5nKCd3YXJuaW5nIG1lc3NhZ2UnKTtcbiAgICAgIHByaW50KCdwcmludCBtZXNzYWdlJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2Vycm9yIG1lc3NhZ2VcXG4nKTtcbiAgICAgIGV4cGVjdChtb2NrU3RkZXJyKS5ub3QudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3dhcm5pbmcgbWVzc2FnZVxcbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkV2l0aCgncHJpbnQgbWVzc2FnZVxcbicpO1xuICAgIH0pO1xuXG4gICAgdGVzdCgnZGVidWcgbWVzc2FnZXMgb25seSBzaG93IGF0IGRlYnVnIGxldmVsJywgKCkgPT4ge1xuICAgICAgc2V0TG9nTGV2ZWwoTG9nTGV2ZWwuSU5GTyk7XG4gICAgICBkZWJ1ZygnZGVidWcgbWVzc2FnZScpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIHNldExvZ0xldmVsKExvZ0xldmVsLkRFQlVHKTtcbiAgICAgIGRlYnVnKCdkZWJ1ZyBtZXNzYWdlJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2RlYnVnIG1lc3NhZ2VcXG4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ3RyYWNlIG1lc3NhZ2VzIG9ubHkgc2hvdyBhdCB0cmFjZSBsZXZlbCcsICgpID0+IHtcbiAgICAgIHNldExvZ0xldmVsKExvZ0xldmVsLkRFQlVHKTtcbiAgICAgIHRyYWNlKCd0cmFjZSBtZXNzYWdlJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgc2V0TG9nTGV2ZWwoTG9nTGV2ZWwuVFJBQ0UpO1xuICAgICAgdHJhY2UoJ3RyYWNlIG1lc3NhZ2UnKTtcbiAgICAgIGV4cGVjdChtb2NrU3RkZXJyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgndHJhY2UgbWVzc2FnZVxcbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnbWVzc2FnZSBmb3JtYXR0aW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ2Zvcm1hdHMgbWVzc2FnZXMgd2l0aCBtdWx0aXBsZSBhcmd1bWVudHMnLCAoKSA9PiB7XG4gICAgICBwcmludCgnVmFsdWU6ICVkLCBTdHJpbmc6ICVzJywgNDIsICd0ZXN0Jyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1ZhbHVlOiA0MiwgU3RyaW5nOiB0ZXN0XFxuJyk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KCdoYW5kbGVzIHByZWZpeCBjb3JyZWN0bHknLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVmaXhlZExvZyA9IHByZWZpeCgnUFJFRklYJyk7XG4gICAgICBwcmVmaXhlZExvZygndGVzdCBtZXNzYWdlJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ1BSRUZJWCB0ZXN0IG1lc3NhZ2VcXG4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgY3VzdG9tIHN0eWxlcycsICgpID0+IHtcbiAgICAgIHN1Y2Nlc3MoJ3N1Y2Nlc3MgbWVzc2FnZScpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdzdWNjZXNzIG1lc3NhZ2VcXG4nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvcmtlZCBsb2dnaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ2J1ZmZlcnMgbWVzc2FnZXMgd2hlbiBjb3JrZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB3aXRoQ29ya2VkTG9nZ2luZyhhc3luYyAoKSA9PiB7XG4gICAgICAgIHByaW50KCdtZXNzYWdlIDEnKTtcbiAgICAgICAgcHJpbnQoJ21lc3NhZ2UgMicpO1xuICAgICAgICBleHBlY3QobW9ja1N0ZGVycikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ21lc3NhZ2UgMVxcbicpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdtZXNzYWdlIDJcXG4nKTtcbiAgICB9KTtcblxuICAgIHRlc3QoJ2hhbmRsZXMgbmVzdGVkIGNvcmtpbmcgY29ycmVjdGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgd2l0aENvcmtlZExvZ2dpbmcoYXN5bmMgKCkgPT4ge1xuICAgICAgICBwcmludCgnb3V0ZXIgMScpO1xuICAgICAgICBhd2FpdCB3aXRoQ29ya2VkTG9nZ2luZyhhc3luYyAoKSA9PiB7XG4gICAgICAgICAgcHJpbnQoJ2lubmVyJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmludCgnb3V0ZXIgMicpO1xuICAgICAgICBleHBlY3QobW9ja1N0ZGVycikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgICAgZXhwZWN0KG1vY2tTdGRlcnIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdvdXRlciAxXFxuJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2lubmVyXFxuJyk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ291dGVyIDJcXG4nKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3RpbWVzdGFtcCBhbmQgcHJlZml4IGhhbmRsaW5nJywgKCkgPT4ge1xuICAgIHRlc3QoJ2NvbWJpbmVzIHRpbWVzdGFtcCBhbmQgcHJlZml4IGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGxvZyh7XG4gICAgICAgIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICAgICAgICBtZXNzYWdlOiAndGVzdCBtZXNzYWdlJyxcbiAgICAgICAgdGltZXN0YW1wOiB0cnVlLFxuICAgICAgICBwcmVmaXg6ICdQUkVGSVgnLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1N0ZGVycikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdNYXRjaGluZygvXlBSRUZJWCBcXFtcXGR7Mn06XFxkezJ9OlxcZHsyfVxcXSB0ZXN0IG1lc3NhZ2VcXG4kLyksXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19